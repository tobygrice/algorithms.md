## The Interview Process
Technical assessment is scored on gut feeling
- talk through thought process as much as possible
Assessed on:
- Analytical skills: optimal? help needed? how long to solve?
- Coding skills: potential errors, styling, knowledge of syntax
- Technical knowledge
- Experience
- Culture fit / communication skills

If you haven't heard back from a company within 3 - 5 business days after your interview, check in (politely) with your recruiter.

Can I re-apply to a company after getting rejected?
- Almost always, but you typically have to wait a bit (6 months to a year).
- Your first bad interview usually won't affect you too much when you re-interview.

## Behind the Scenes
- Initial screening interview often involves coding and algorithms questions, and the bar can be just as high as it is for in-person interviews
- You typically do one or two screening interviewers before being brought on-site. 
	- In an on-site interview round, you usually have 3 to 6 in-person interviews. 
	- One of these is often over lunch. The lunch interview is usually not technical, and the interviewer may not even submit feedback. This is a good person to discuss your interests with and to ask about the company culture. 
	- Your other interviews will be mostly technical and will involve a combination of coding, algorithm, design/architecture, and behavioural/experience questions.
- If you have waited more than a week, you should follow up with your recruiter. 
	- If your recruiter does not respond, this does **not** mean that you are rejected
- Each interview is a blank slate and interviews do not share feedback
- To extend an offer, the HC wants to see at least one interviewer who is an "enthusiastic endorser:' In other words, a packet with scores of 3.6, 3.1, 3.1 and 2.6 is better than all 3.1 s. 
	- You do not necessarily need to excel in every interview, and your phone screen performance is usually not a strong factor in the final decision.


## Before the Interview
### Resume
For less than ten years experience, resume should be 1 page only

**Employment History**
- Only include relevant history
- Writing Strong Bullets: "Accomplished X by implementing Y which led to Z"
- Show what you did, how you did it, and what the results were
**Projects**
- 2-4 most significant projects
- What the project was and which languages or technologies it employed.
- Optional: was it an individual or a team project, was is completed for a course or independently
**Programming Languages and Software**
- Be conservative about what software you list, and understand what's appropriate for the company
- Only list software that could not be considered assumed knowledge (e.g. obscure IDEs) that you know is relevant to the company
**Languages**
- Listing everything you've ever worked with is dangerous. Many interviewers consider anything on your resume to be "fair game" as far as the interview.
- One alternative is to list most of the languages you've used, but add your experience level. 
	- e.g. Languages: Java (expert), C++ (proficient), JavaScript (prior experience).
- Don't focus too much or too little on languages: list at least three, unsure of max
**Other notes**
- do not include age, marital status, or nationality
- some companies will throw out your resume just because of a typo

### Preparation Process
See map on pages 30-31 of CTCI.

## Behavioural questions
### Preparation Grid
See excel.

### Questions
Weaknesses: 
- think of a genuine weakness
- e.g. Sometimes, I don't have a very good attention to detail. While that's good because it lets me execute quickly, it also means that I sometimes make careless mistakes. Because of that, I make sure to always have someone else double check my work.

#### Questions to ask the interviewer
**Genuine Questions**
These are the questions you actually want to know the answers to. Here are a few ideas of questions that are valuable to many candidates: 
1. "What is the ratio of testers to developers to program managers? What is the interaction like? How does project planning happen on the team?" 
2. "What brought you to this company? What has been most challenging for you?" These questions will give you a good feel for what the day-to-day life is like at the company. 

**Insightful Questions** 
These questions demonstrate your knowledge or understanding of technology. 
1. "I noticed that you use technology X. How do you handle problem Y?" 2. "Why did the product choose to use the X protocol over the Y protocol? I know it has benefits like A, B, C, but many companies choose not to use it because of issue D' 
Asking such questions will typically require advance research about the company. 

**Passion Questions** 
These questions are designed to demonstrate your passion for technology. 
They show that you're interested in learning and will be a strong contributor to the company. 
1. 'I'm very interested in scalability, and I'd love to learn more about it. What opportunities are there at this company to learn about this?" 
2. "I'm not familiar with technology X, but it sounds like a very interesting solution. Could you tell me a bit more about how it works?"

#### Answering Questions
- Be specific, not arrogant
	- Want to sound impressive without sounding arrogant
	- Solution: be specific
	- Specificity means giving just the facts and letting the interviewer derive an interpretation.
- Limit details
	- When a candidate blabbers on about a problem, it's hard for an interviewer who isn't well versed in the subject or project to understand it.
	- Stay light on details and just state the key points.
	- Translate or explain impact
- Focus on yourself, not the team
- Give structured answers
	- **Nugget first**
		- starting your response with a "nugget" that succinctly describes what your response will be about
		- Interviewer: "Tell me about a time you had to persuade a group of people to make a big change:' 
		- Candidate: 'Sure, let me tell you about the time when I convinced my school to let undergraduates teach their own courses. Initially, my school had a rule where â€¦'
	- **S.A.R. (Situation, Action, Result)**
		- start off outlining the situation, then explaining the actions you took, and lastly, describing the result.
		- The situation and the result should be succinct. Your interviewer generally does not need many details to understand what happened and, in fact, may be confused by them.
		- Long, but good, example:
		- ''Tell me about a challenging interaction with a teammate:' 
		- **Situation**: On my operating systems project, I was assigned to work with three other people. While two were great, the third team member didn't contribute much. He stayed quiet during meetings, rarely chipped in during email discussions, and struggled to complete his components. This was an issue not only because it shifted more work onto us, but also because we didn't know if we could count on him. 
		- **Action**: I didn't want to write him off completely yet, so I tried to resolve the situation. I did three things. First, I wanted to understand why he was acting like this. Was it laziness? Was he busy with something else? I struck up a conversation with him and then asked him open-ended questions about how he felt it was going. Interestingly, basically out of nowhere, he said that he wanted to take on the writeup, which is one of the most time intensive parts. This showed me that it wasn't laziness; it was that he didn't feel like he was good enough to write code. Second, now that I understand the cause, I tried to make it clear that he shouldn't fear messing up. I told him about some of the bigger mistakes that I made and admitted that I wasn't clear about a lot of parts of the project either. Third and finally, I asked him to help me with breaking out some of the components of the project. We sat down together and designed a thorough spec for one of the big component, in much more detail than we had before. Once he could see all the pieces, it helped show him that the project wasn't as scary as he'd assumed. 
		- **Result**: With his confidence raised, he now offered to take on a bunch of the smaller coding work, and then eventually some of the biggest parts. He finished all his work on time, and he contributed more in discussions. We were happy to work with him on a future project.
A sample table for stories:

|         | Nugget | Situation | Action(s) | Result | What it says |
| ------- | ------ | --------- | --------- | ------ | ------------ |
| Story 1 |        |           |           |        |              |
| Story 2 |        |           |           |        |              |
What it says
- Think about what the story says about you
- What personality attributes has the candidate demonstrated?
- In many cases, the answer is"none:'
- That usually means you need to rework how you communicate the story to make the attribute clearer. 
- You don't want to explicitly say, "I did X because I have empathy;' but you can go one step away from that. 
- For example: 
	- Less Clear Attribute: "I called up the client and told him what happened"
	- More Clear Attribute (Empathy and Courage): "I made sure to call the client myself, because I knew that he would appreciate hearing it directly from me"

##### Tell me about yourself
Initial pitch structure:
1. Current role (headline only)
2. College background
3. Post-college and onwards (work experience)
4. Current role (details)
5. Outside of work
6. Wrap up (reason for application)

Example:
1. Current Role Headline: I'm a software engineer at Microworks, where I've been leading the Android team for the last five years.
2. College: My background is in computer science. I did my undergrad at Berkeley and spent a few summers working at startups, including one where I attempted to launch my own business. 
3. Post College & Onwards: After college, I wanted to get some exposure to larger corporations, so I joined Amazon as a developer. It was a great experience. I learned a ton about large system design and I got to really drive the launch of a key part of AWS. That actually showed me that I really wanted to be in a more entrepreneurial environment. 
4. Current Role Details: One of my old managers from Amazon recruited me out to join her startup, which was what brought me to Microworks. Here, I did the initial system architecture, which has scaled pretty well with our rapid growth. I then took an opportunity to lead the Android team. I do manage a team of three, but my role is primarily with technical leadership: architecture, coding, etc. 
5. Outside of Work: Outside of work, I've been participating in some hackathons - mostly doing iOS development there as a way to learn it more deeply. I'm also active as a moderator on online forums around Android development. 
6. Wrap Up: I'm looking now for something new, and your company caught my eye. I've always loved the connection with the user, and I really want to get back to a smaller environment too.

## Big O and complexity analysis
We rarely ever discuss best case time complexity, because it's not a very useful concept. After all, we could take essentially any algorithm, special case some input, and then get an O (1) time in the best case. 
For many-probably most-algorithms, the worst case and the expected case are the same. Sometimes they're different, though, and we need to describe both of the runtimes. 
**What is the relationship between best/worst/expected case and big O/theta/omega?** 
- It's easy for candidates to muddle these concepts (probably because both have some concepts of "higher", lower" and "exactly right"), but there is no particular relationship between the concepts.
- Best, worst, and expected cases describe the big O (or big theta) time for particular inputs or scenarios. Big O, big omega, and big theta describe the upper, lower, and tight bounds for the runtime.

### Space complexity
Space complexity is a parallel concept to time complexity. If we need to create an array of size n, this will require $O(n)$ space. If we need a two-dimensional array of size $n \times n$, this will require $O(n^2)$ space.
Stack space in recursive calls counts, too. For example, code like this would take $O(n)$ time and $O(n)$ space
```C
int sum(int n) {/*Ex 1.*/ 
	if (n <= 0) { 
		return 0;
	}
	return n + sum(n-1); // adds a level to the stack n times -> O(n) space
}
```
Do not confuse recursive calls with regular calls: calling a function `n` times is still O(1) space if those calls do not exist simultaneously on the stack.

### Drop Constants
It is very possible for $O(N)$ code to run faster than $O(1)$ code for specific inputs. Big O just describes the rate of increase. For this reason, we drop the constants in runtime. People resist doing this, but consider the following example:
```C
int min = INT_MAX;
int max = INT_MIN;
for (int x : array) {
	if (x < min) min = x;
}
for (int x : array) {
	if (x > max) max = x;
}
```
Some people may see this code and want to call it $O(2n)$. But consider the alternate version below:
```C
int min = INT_MAX;
int max = INT_MIN;
for (int x : array) {
	if (x < min) min = x;
	if (x > max) max = x;
}
```
It is clear to see this is no faster (or slower) than the previous snippet, but the same people would be happy calling this $O(n)$.
Including constants is meaningless and doesn't help much - how long it takes constant time operations to execute is dictated by the operations themselves and the hardware. This is not helpful to think about, so it's not worth including in time complexity. 

### Drop Non-Dominant Terms
We only care about the dominant terms:
- $O(N^2 + N)$ becomes $O(N^2)$. 
- $O(N + \log N)$ becomes $O(N)$. 
- $O(5*2^N + 1000*N^{100})$ becomes $O(2^N)$.
We might still have a sum in a runtime in terms of inputs. For example, the expression $O(B^2 + A)$ cannot be reduced (without some special knowledge of A and B).

## Amortised Time
