## The Interview Process
Technical assessment is scored on gut feeling
- talk through thought process as much as possible
Assessed on:
- Analytical skills: optimal? help needed? how long to solve?
- Coding skills: potential errors, styling, knowledge of syntax
- Technical knowledge
- Experience
- Culture fit / communication skills

If you haven't heard back from a company within 3 - 5 business days after your interview, check in (politely) with your recruiter.

Can I re-apply to a company after getting rejected?
- Almost always, but you typically have to wait a bit (6 months to a year).
- Your first bad interview usually won't affect you too much when you re-interview.

## Behind the Scenes
- Initial screening interview often involves coding and algorithms questions, and the bar can be just as high as it is for in-person interviews
- You typically do one or two screening interviewers before being brought on-site. 
	- In an on-site interview round, you usually have 3 to 6 in-person interviews. 
	- One of these is often over lunch. The lunch interview is usually not technical, and the interviewer may not even submit feedback. This is a good person to discuss your interests with and to ask about the company culture. 
	- Your other interviews will be mostly technical and will involve a combination of coding, algorithm, design/architecture, and behavioural/experience questions.
- If you have waited more than a week, you should follow up with your recruiter. 
	- If your recruiter does not respond, this does **not** mean that you are rejected
- Each interview is a blank slate and interviews do not share feedback
- To extend an offer, the HC wants to see at least one interviewer who is an "enthusiastic endorser:' In other words, a packet with scores of 3.6, 3.1, 3.1 and 2.6 is better than all 3.1 s. 
	- You do not necessarily need to excel in every interview, and your phone screen performance is usually not a strong factor in the final decision.


## Before the Interview
### Resume
For less than ten years experience, resume should be 1 page only

**Employment History**
- Only include relevant history
- Writing Strong Bullets: "Accomplished X by implementing Y which led to Z"
- Show what you did, how you did it, and what the results were
**Projects**
- 2-4 most significant projects
- What the project was and which languages or technologies it employed.
- Optional: was it an individual or a team project, was is completed for a course or independently
**Programming Languages and Software**
- Be conservative about what software you list, and understand what's appropriate for the company
- Only list software that could not be considered assumed knowledge (e.g. obscure IDEs) that you know is relevant to the company
**Languages**
- Listing everything you've ever worked with is dangerous. Many interviewers consider anything on your resume to be "fair game" as far as the interview.
- One alternative is to list most of the languages you've used, but add your experience level. 
	- e.g. Languages: Java (expert), C++ (proficient), JavaScript (prior experience).
- Don't focus too much or too little on languages: list at least three, unsure of max
**Other notes**
- do not include age, marital status, or nationality
- some companies will throw out your resume just because of a typo

### Preparation Process
See map on pages 30-31 of CTCI.

## Behavioural questions
### Preparation Grid
See excel.

### Questions
Weaknesses: 
- think of a genuine weakness
- e.g. Sometimes, I don't have a very good attention to detail. While that's good because it lets me execute quickly, it also means that I sometimes make careless mistakes. Because of that, I make sure to always have someone else double check my work.

#### Questions to ask the interviewer
**Genuine Questions**
These are the questions you actually want to know the answers to. Here are a few ideas of questions that are valuable to many candidates: 
1. "What is the ratio of testers to developers to program managers? What is the interaction like? How does project planning happen on the team?" 
2. "What brought you to this company? What has been most challenging for you?" These questions will give you a good feel for what the day-to-day life is like at the company. 

**Insightful Questions** 
These questions demonstrate your knowledge or understanding of technology. 
1. "I noticed that you use technology X. How do you handle problem Y?" 2. "Why did the product choose to use the X protocol over the Y protocol? I know it has benefits like A, B, C, but many companies choose not to use it because of issue D' 
Asking such questions will typically require advance research about the company. 

**Passion Questions** 
These questions are designed to demonstrate your passion for technology. 
They show that you're interested in learning and will be a strong contributor to the company. 
1. 'I'm very interested in scalability, and I'd love to learn more about it. What opportunities are there at this company to learn about this?" 
2. "I'm not familiar with technology X, but it sounds like a very interesting solution. Could you tell me a bit more about how it works?"

#### Answering Questions
- Be specific, not arrogant
	- Want to sound impressive without sounding arrogant
	- Solution: be specific
	- Specificity means giving just the facts and letting the interviewer derive an interpretation.
- Limit details
	- When a candidate blabbers on about a problem, it's hard for an interviewer who isn't well versed in the subject or project to understand it.
	- Stay light on details and just state the key points.
	- Translate or explain impact
- Focus on yourself, not the team
- Give structured answers
	- **Nugget first**
		- starting your response with a "nugget" that succinctly describes what your response will be about
		- Interviewer: "Tell me about a time you had to persuade a group of people to make a big change:' 
		- Candidate: 'Sure, let me tell you about the time when I convinced my school to let undergraduates teach their own courses. Initially, my school had a rule where …'
	- **S.A.R. (Situation, Action, Result)**
		- start off outlining the situation, then explaining the actions you took, and lastly, describing the result.
		- The situation and the result should be succinct. Your interviewer generally does not need many details to understand what happened and, in fact, may be confused by them.
		- Long, but good, example:
		- ''Tell me about a challenging interaction with a teammate:' 
		- **Situation**: On my operating systems project, I was assigned to work with three other people. While two were great, the third team member didn't contribute much. He stayed quiet during meetings, rarely chipped in during email discussions, and struggled to complete his components. This was an issue not only because it shifted more work onto us, but also because we didn't know if we could count on him. 
		- **Action**: I didn't want to write him off completely yet, so I tried to resolve the situation. I did three things. First, I wanted to understand why he was acting like this. Was it laziness? Was he busy with something else? I struck up a conversation with him and then asked him open-ended questions about how he felt it was going. Interestingly, basically out of nowhere, he said that he wanted to take on the writeup, which is one of the most time intensive parts. This showed me that it wasn't laziness; it was that he didn't feel like he was good enough to write code. Second, now that I understand the cause, I tried to make it clear that he shouldn't fear messing up. I told him about some of the bigger mistakes that I made and admitted that I wasn't clear about a lot of parts of the project either. Third and finally, I asked him to help me with breaking out some of the components of the project. We sat down together and designed a thorough spec for one of the big component, in much more detail than we had before. Once he could see all the pieces, it helped show him that the project wasn't as scary as he'd assumed. 
		- **Result**: With his confidence raised, he now offered to take on a bunch of the smaller coding work, and then eventually some of the biggest parts. He finished all his work on time, and he contributed more in discussions. We were happy to work with him on a future project.
A sample table for stories:

|         | Nugget | Situation | Action(s) | Result | What it says |
| ------- | ------ | --------- | --------- | ------ | ------------ |
| Story 1 |        |           |           |        |              |
| Story 2 |        |           |           |        |              |
What it says
- Think about what the story says about you
- What personality attributes has the candidate demonstrated?
- In many cases, the answer is"none:'
- That usually means you need to rework how you communicate the story to make the attribute clearer. 
- You don't want to explicitly say, "I did X because I have empathy;' but you can go one step away from that. 
- For example: 
	- Less Clear Attribute: "I called up the client and told him what happened"
	- More Clear Attribute (Empathy and Courage): "I made sure to call the client myself, because I knew that he would appreciate hearing it directly from me"

##### Tell me about yourself
Initial pitch structure:
1. Current role (headline only)
2. College background
3. Post-college and onwards (work experience)
4. Current role (details)
5. Outside of work
6. Wrap up (reason for application)

Example:
1. Current Role Headline: I'm a software engineer at Microworks, where I've been leading the Android team for the last five years.
2. College: My background is in computer science. I did my undergrad at Berkeley and spent a few summers working at startups, including one where I attempted to launch my own business. 
3. Post College & Onwards: After college, I wanted to get some exposure to larger corporations, so I joined Amazon as a developer. It was a great experience. I learned a ton about large system design and I got to really drive the launch of a key part of AWS. That actually showed me that I really wanted to be in a more entrepreneurial environment. 
4. Current Role Details: One of my old managers from Amazon recruited me out to join her startup, which was what brought me to Microworks. Here, I did the initial system architecture, which has scaled pretty well with our rapid growth. I then took an opportunity to lead the Android team. I do manage a team of three, but my role is primarily with technical leadership: architecture, coding, etc. 
5. Outside of Work: Outside of work, I've been participating in some hackathons - mostly doing iOS development there as a way to learn it more deeply. I'm also active as a moderator on online forums around Android development. 
6. Wrap Up: I'm looking now for something new, and your company caught my eye. I've always loved the connection with the user, and I really want to get back to a smaller environment too.

## Big O and complexity analysis
We rarely ever discuss best case time complexity, because it's not a very useful concept. After all, we could take essentially any algorithm, special case some input, and then get an O (1) time in the best case. 
For many-probably most-algorithms, the worst case and the expected case are the same. Sometimes they're different, though, and we need to describe both of the runtimes. 
**What is the relationship between best/worst/expected case and big O/theta/omega?** 
- It's easy for candidates to muddle these concepts (probably because both have some concepts of "higher", lower" and "exactly right"), but there is no particular relationship between the concepts.
- Best, worst, and expected cases describe the big O (or big theta) time for particular inputs or scenarios. Big O, big omega, and big theta describe the upper, lower, and tight bounds for the runtime.

### Space complexity
Space complexity is a parallel concept to time complexity. If we need to create an array of size n, this will require $O(n)$ space. If we need a two-dimensional array of size $n \times n$, this will require $O(n^2)$ space.
Stack space in recursive calls counts, too. For example, code like this would take $O(n)$ time and $O(n)$ space
```C
int sum(int n) {/*Ex 1.*/ 
	if (n <= 0) { 
		return 0;
	}
	return n + sum(n-1); // adds a level to the stack n times -> O(n) space
}
```
Do not confuse recursive calls with regular calls: calling a function `n` times is still O(1) space if those calls do not exist simultaneously on the stack.

### Drop Constants
It is very possible for $O(N)$ code to run faster than $O(1)$ code for specific inputs. Big O just describes the rate of increase. For this reason, we drop the constants in runtime. People resist doing this, but consider the following example:
```C
int min = INT_MAX;
int max = INT_MIN;
for (int x : array) {
	if (x < min) min = x;
}
for (int x : array) {
	if (x > max) max = x;
}
```
Some people may see this code and want to call it $O(2n)$. But consider the alternate version below:
```C
int min = INT_MAX;
int max = INT_MIN;
for (int x : array) {
	if (x < min) min = x;
	if (x > max) max = x;
}
```
It is clear to see this is no faster (or slower) than the previous snippet, but the same people would be happy calling this $O(n)$.
Including constants is meaningless and doesn't help much - how long it takes constant time operations to execute is dictated by the operations themselves and the hardware. This is not helpful to think about, so it's not worth including in time complexity. 

### Drop Non-Dominant Terms
We only care about the dominant terms:
- $O(N^2 + N)$ becomes $O(N^2)$. 
- $O(N + \log N)$ becomes $O(N)$. 
- $O(5*2^N + 1000*N^{100})$ becomes $O(2^N)$.
We might still have a sum in a runtime in terms of inputs. For example, the expression $O(B^2 + A)$ cannot be reduced (without some special knowledge of A and B).

### Amortised Time
Best explained with an example:
- An `ArrayList`, or a dynamically resizing array, allows you to have the benefits of an array while offering flexibility in size. 
	- You won't run out of space in the `ArrayList` since its capacity will grow as you insert elements. 
	- An `ArrayList` is implemented with an array. When the array hits capacity, the `ArrayList` class will create a new array with double the capacity and copy all the elements over to the new array. 
- How do you describe the runtime of insertion? 
	- This is a tricky question. The array could be full. If the array contains N elements, then inserting a new element will take O(N) time. You will have to create a new array of size 2N and then copy N elements over. 
	- However, we also know that this doesn't happen very often. The vast majority of the time insertion will be in O(1) time. 
	- We need a concept that takes both into account. 
	- This is what amortized time does. It allows us to describe that, yes, this worst case happens every once in a while. But once it happens, it won't happen again for so long that the cost is "amortized."

### Recursive Runtimes
Consider a recursive implementation of Fibonacci:
```C
int f(int n) {
	if (n <= 1) {
		return n; // f(0) = 0, f(1) = 1
	}
	return f(n - 1) + f(n - 2)
}
```
Each function spawns two children, so it creates a binary tree as follows:
![[Pasted image 20251227162224.png]]
This tree will have depth `n`. There will be $2^{N+1}-1$ nodes.

**Try to remember this pattern.** When you have a recursive function that makes multiple calls, the runtime will often (but not always) look like $O(\text {branches} ^ \text {depth})$, where $\text {branches}$ is the number of times each recursive call branches. In this case, this gives us $O(2^N)$.


### Other Examples
Consider a nested loop that starts at `i+1`:
```C
void printUnorderedPairs(int[] array) {
	for (int i = 0; i < array.length; i++) {
		for (int j = i + 1; j < array.length; j++) {
			print(array[i] + "," + array[j])
		}
	}
}
```
The first time through j runs for N-1 steps. The second time, it's N-2 steps. Then N-3 steps. And so on. Therefore, the number of steps total is: $(N-1) + (N-2) + (N-3) + ... + 2 + 1$, which is the sum of 1 through N-1. This is equal to $\frac {N(N-1)} {2} = 0.5N^2 - 0.5N$, which is $O(N^2)$

Another way to think about it:
- Think about the number of iterations in the inner loop, for each value of `i`
- `1,2,3,...,N-1`
- The average value in this sequence is roughly $N/2$
- Therefore, on average, $N/2$ operations are performed $N$ times
- This is $O(N^2)$

---

Don't be afraid to use multiple variables if you need them.

---

Challenging example:
```C
void permutation(String str) {
	permutation(str, "");
}

void permutation(String str, String prefix) {
	if (str.length() == 0) {
		System.out.println(prefix);
	} else {
		for (int i= 0; i < str.length(); i++) {
			String rem = str.substring(0, i) + str.substring(i + 1);
			permutation(rem, prefix + str.charAt(i));
		}
	}
} 
```
How many times does permutation get called in its base case? 
- If we were to generate a permutation, then we would need to pick characters for each "slot:' Suppose we had 7 characters in the string. In the first slot, we have 7 choices. Once we pick the letter there, we have 6 choices for the next slot. (Note that this is 6 choices for each of the 7 choices earlier.) Then 5 choices for the next slot, and so on. 
- Therefore, the total number of options is 7 * 6 * 5 * 4 * 3 * 2 * 1, which is also expressed as 7! (7 factorial). 
- This tells us that there are n! permutations. 
- Therefore, permutation is called n! times in its base case (when prefix is the full permutation). 
How many times does permutation get called before its base case? 
- But, of course, we also need to consider how many times lines 9 through 12 are hit. 
- Picture a large call tree representing all the calls. There are n! leaves, as shown above. 
- Each leaf is attached to a path of length n. 
- Therefore, we know there will be no more than $n * n!$ nodes (function calls) in this tree. 
How long does each function call take? 
- Executing line 7 takes O(n) time since each character needs to be printed. 
- Line 10 and line 11 will also take O(n) time combined, due to the string concatenation. 
- Observe that the sum of the lengths of `rem`, `prefix`, and `str.charAt(i)` will always be n. 
- Each node in our call tree therefore corresponds to O(n) work. 
What is the total runtime? 
- Since we are calling permutation $O(n * n!)$ times (as an upper bound), and each one takes $O(n)$ time, the total runtime will not exceed $O (n^2 * {n}!)$ . 


### Additional Problems
*Seem like good practice for big O analysis. Page 55.*


## Technical Questions
Here's a list of the absolute, must-have knowledge:

| Data Structures        | Algorithms           | Concepts                |
| ---------------------- | -------------------- | ----------------------- |
| Linked Lists           | Breadth-First Search | Bit Manipulation        |
| Trees, Tries, & Graphs | Depth-First Search   | Memory (Stack vs. Heap) |
| Stacks & Queues        | Binary Search        | Recursion               |
| Heaps                  | Merge Sort           | Dynamic Programming     |
| Vectors / ArrayLists   | Quick Sort           | Big O Time & Space      |
| Hash Tables            |                      |                         |

Hash tables are very important. For each of these topics, make sure you understand how to use and implement them and, where applicable, the space and time complexity.
![[ctci-coding-skills.pdf]]

### Process of Developing a Solution
- Pay attention to all details and note them down if required
	- It is unlikely your interviewer will provide a detail that is not necessary to the solution
	- e.g. "Given two arrays that are sorted, find …"
	- You probably need to know that the data is sorted
- Create good examples. Examples should be: 
	- sufficiently large
	- specific (use real numbers/strings)
	- not special case
- State a brute force
	- create a non-optimal, brute force solution
	- you want your interview to know you can see the easy solution
	- is a good starting point for optimisations
- Optimise 
	- **Look for any unused information.** Did your interviewer tell you that the array was sorted? How can you leverage that information? 
	- **Use a fresh example.** Sometimes, just seeing a different example will unclog your mind or help you see a pattern in the problem. 
	- **Solve it "incorrectly."** Just like having an inefficient solution can help you find an efficient solution, having an incorrect solution might help you find a correct solution. For example, if you're asked to generate a random value from a set such that all values are equally likely, an incorrect solution might be one that returns a semi-random value: Any value could be returned, but some are more likely than others. You can then think about why that solution isn't perfectly random. Can you rebalance the probabilities? 
	- **Make time vs. space tradeoff.** Sometimes storing extra state about the problem can help you optimize the runtime. 
	- **Precompute information.** Is there a way that you can reorganize the data (sorting, etc.) or compute some values upfront that will help save time in the long run? 
	- **Use a hash table.** Hash tables are widely used in interview questions and should be at the top of your mind. 
	- **Think about the best conceivable runtime.**
- Walk through
	- After developing algorithm, walk through it before implementing
	- You can write pseudocode, but keep it *very* high level
		- e.g. (1) search array (2) find biggest (3) insert in heap
		- e.g. if p < q, move p, else move q
		- Don't have code implemented in English - no for loops or anything
- Implement
	- Write modularised code
		- e.g. If your algorithm uses a matrix initialized to `{{ 1, 2, 3 }, { 4, 5, 6 }, ...}` , don't waste your time writing this initialization code. Just pretend you have a function `initIncrementalMatrix(int m, int n)`.
	- Use other classes/structs where appropriate. 
		- If you need to return a list of start and end points from a function, you could do this as a two-dimensional array.
		- It's better though to do this as a list of `StartEndPair` (or possibly `Range`) objects.
		- You don't necessarily have to implement the class, just pretend it exists
	- Use logical variable names
		- Helps both you and the interviewer
- Test
	- **Start with a "conceptual" test.** A conceptual test means just reading and analysing what each line of code does. Think about it like you're explaining the lines of code for a code reviewer. Does the code do what you think it should do? 
	- **Weird looking code.** Double check that line of code that says `x = length - 2`. Investigate that for loop that starts at `i = 1`. While you undoubtedly did this for a reason, it's really easy to get it just slightly wrong. 
	- **Hot spots.** You've coded long enough to know what things are likely to cause problems. Base cases in recursive code. Integer division. Null nodes in binary trees. The start and end of iteration through a linked list. Double check that stuff.
	- **Small test cases.** This is the first time we use an actual, specific test case to test the code. Don't use that nice, big 8-element array from the algorithm part. Instead, use a 3 or 4 element array. It'll likely discover the same bugs, but it will be much faster to do so. 
	- **Special cases.** Test your code against null or single element values, the extreme cases, and other special cases.
	- When you find bugs (and you probably will), you should of course fix them. But don't just make the first correction you think of. Instead, carefully analyse why the bug occurred and ensure that your fix is the best one.

### Optimisation Techniques

